<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="rxColumnMapReplacement" xml:space="preserve">
    <value>(?&lt;cell&gt;((?&lt;=\|\s*){content}(?=\s*\|))|((?&lt;head&gt;\#{1,}\s*){content}))</value>
    <comment>Regular expression containing an interpolated variable named {content} which should be replaced before using the expression to find and replace all column mapping instances with the current replacement.</comment>
  </data>
  <data name="rxCssNameValue" xml:space="preserve">
    <value>(?i:\s*(?&lt;name&gt;[^\:\;]+)\s*\:\s*(?&lt;value&gt;[^\;]+)\s*)</value>
    <comment>Regular expression pattern to extract one or more CSS name: value patterns from a string.</comment>
  </data>
  <data name="rxDocStyleSectionBackEven" xml:space="preserve">
    <value>(?i:^(?&lt;stylename&gt;sectionbackgroundcoloreven)$)</value>
    <comment>Regular expression pattern to match the even section background document style name.</comment>
  </data>
  <data name="rxDocStyleSectionBackEvenOdd" xml:space="preserve">
    <value>(?i:^(?&lt;stylename&gt;sectionbackgroundcolor(?&lt;evenodd&gt;(even|odd)))$)</value>
    <comment>Regular expression pattern to match the even and odd section background document style names.</comment>
  </data>
  <data name="rxDocStyleSectionBackOdd" xml:space="preserve">
    <value>(?i:^(?&lt;stylename&gt;sectionbackgroundcolorodd)$)</value>
    <comment>Regular expression pattern to match the odd section background document style name.</comment>
  </data>
  <data name="rxFilenameAndExtension" xml:space="preserve">
    <value>(?&lt;filename&gt;[^\.]+)(?&lt;extension&gt;(\.[^\.]+)*)</value>
    <comment>Regular expression pattern to match a filename and optional extension.</comment>
  </data>
  <data name="rxFolderElement" xml:space="preserve">
    <value>(?i:(?&lt;folder&gt;([a-z]+\:(//){0,1}|\\\\\w+|[^\\/]+)))</value>
    <comment>Regular expression pattern for finding all individual folder elements in a path name.</comment>
  </data>
  <data name="rxHtmlHeading" xml:space="preserve">
    <value>(?s:(?&lt;heading&gt;\&lt;h(?&lt;digit&gt;\d)(\s+(?&lt;attributes&gt;[^\&gt;]*)){0,1}\&gt;\s*(?&lt;content&gt;[^\&lt;]*)\s*\&lt;/h\k&lt;digit&gt;\&gt;))</value>
    <comment>Regular expression pattern to extract parts of an HTML heading.</comment>
  </data>
  <data name="rxHtmlHeadingNoFont" xml:space="preserve">
    <value>(?s:(?&lt;heading&gt;\&lt;h(?&lt;digit&gt;\d)(?&lt;attributes&gt;[^\&gt;]*)\&gt;(?!\s*\&lt;font[^\&gt;]*\&gt;)\s*(?&lt;content&gt;.*?)\s*(?&lt;!\&lt;/font\&gt;\s*)\&lt;/h\k&lt;digit&gt;\&gt;))</value>
    <comment>Regular expression pattern to match HTML headings not treated with a font element.</comment>
  </data>
  <data name="rxHtmlHexColor" xml:space="preserve">
    <value>(?i:(?&lt;hexcolor&gt;\#(?&lt;r&gt;[0-9a-f]{2})(?&lt;g&gt;[0-9a-f]{2})(?&lt;b&gt;[0-9a-f]{2})(?&lt;a&gt;[0-9a-f]{2}){0,1}))</value>
    <comment>Regular expression pattern for identifying a HEX-6 or HEX-8 value and extracting its values.</comment>
  </data>
  <data name="rxHtmlTableCellNoFont" xml:space="preserve">
    <value>(?s:(?&lt;cell&gt;\&lt;t(?&lt;celltype&gt;d|h)(?&lt;attributes&gt;[^\&gt;]*)\&gt;(?!\s*\&lt;font[^\&gt;]*\&gt;)\s*(?&lt;content&gt;.*?)\s*(?&lt;!\&lt;/font\&gt;\s*)\&lt;/t\k&lt;celltype&gt;\&gt;))</value>
    <comment>Regular expression pattern to match an HTML table cell with no internal font node.</comment>
  </data>
  <data name="rxHtmlTableFirstRow" xml:space="preserve">
    <value>(?s:\&lt;table[^\&gt;]*\&gt;\s*\&lt;tr[^\&gt;]*\&gt;\s*(?&lt;firstrow&gt;(\&lt;t(?&lt;celltype&gt;d|h)[^\&gt;]*\&gt;.*?\&lt;/t\k&lt;celltype&gt;\&gt;)+)\s*\&lt;/tr\&gt;)</value>
    <comment>Regular expression pattern to match the first row content of an HTML table.</comment>
  </data>
  <data name="rxInterpolatedExpression" xml:space="preserve">
    <value>(?s:{(?&lt;variable&gt;\w+[^}]*)})</value>
    <comment>Regular expression pattern to extract interpolated variable expressions from text.</comment>
  </data>
  <data name="rxLine" xml:space="preserve">
    <value>(?s:(?&lt;line&gt;[^\r\n]*)(\r{0,1}\n|$))</value>
    <comment>Regular expression that matches an individual text file line.</comment>
  </data>
  <data name="rxMarkdownHeading" xml:space="preserve">
    <value>(?m:^[\t ]{0,3}(?&lt;level&gt;\#+)[\t ]+(?&lt;line&gt;.*)$)</value>
    <comment>Regular expression pattern to extract the content of a heading from a line.</comment>
  </data>
  <data name="rxMarkdownHeadingLevelContentNoFont" xml:space="preserve">
    <value>(?s:(?&lt;level&gt;\#{1,9})[\t ]+(?!\&lt;font[^\&gt;]*\&gt;)(?&lt;content&gt;[^\r\n]+)(?!\&lt;/font\&gt;))</value>
    <comment>Regular expression pattern to match markdown headings that have not yet had font overrides applied.</comment>
  </data>
  <data name="rxMarkdownHeadingN" xml:space="preserve">
    <value>(?m:^[\t ]{0,3}(?&lt;level&gt;\#{{minLevel},{maxLevel}})[\t ]+(?&lt;line&gt;.*)$)</value>
    <comment>Regular expression for matching a Markdown heading level between {minLevel} and {maxLevel}.</comment>
  </data>
  <data name="rxMarkdownHeadingNoFont" xml:space="preserve">
    <value>(?m:^(?&lt;prefix&gt;[\t ]{0,3})(?&lt;level&gt;\#+)[\t ]+(?!\s*\&lt;font[^\&gt;]*\&gt;)\s*(?&lt;line&gt;.*)$(?&lt;!\&lt;/font\&gt;\s*))</value>
    <comment>Regular expression pattern to match a markdown heading whose content has not been wrapped in a font.</comment>
  </data>
  <data name="rxMarkdownHtmlLine" xml:space="preserve">
    <value>(?m:(?i:^(?&lt;line&gt;\s*\&lt;.*)$))</value>
    <comment>Regular expression pattern to match a line of HTML in markdown content.</comment>
  </data>
  <data name="rxMarkdownLine" xml:space="preserve">
    <value>(?s:(?&lt;line&gt;(?&lt;=[\r\n]*)[\t ]*---(?=[\r\n]+)))</value>
    <comment>Regular expression pattern to find a horizontal line expressed as Markdown.</comment>
  </data>
  <data name="rxMarkdownLinePart" xml:space="preserve">
    <value>(?m:^(?&lt;line&gt;[\t ]*---)\s*$)</value>
    <comment>Regular expression pattern to determine whether the content of a single line matches a horizontal line.</comment>
  </data>
  <data name="rxMarkdownListItem" xml:space="preserve">
    <value>(?m:^(?&lt;listItem&gt;(?&lt;leadingSpace&gt;[\t ]*)(?&lt;listType&gt;-|[0-9a-zA-Z]+\.)[\t ]{1,4}(?&lt;text&gt;.*))$)</value>
    <comment>Regular expression pattern to extract any unordered or ordered list item from Markdown text.</comment>
  </data>
  <data name="rxMarkdownTableCellNoFont" xml:space="preserve">
    <value>(?s:(?&lt;=\|\s+)(?!\&lt;font[^\&gt;]*\&gt;)(?&lt;content&gt;[^\|]+)(?!\&lt;/font\&gt;)(?=\s+\|))</value>
    <comment>Regular expression pattern to match the content of a markdown cell that has not had a font override.</comment>
  </data>
  <data name="rxMarkdownTableRow" xml:space="preserve">
    <value>(?m:^(?&lt;row&gt;(?&lt;prefix&gt;[\t ]*)(?&lt;content&gt;\|.*\|))\s*$)</value>
    <comment>Regular expression pattern to match a markdown table row.</comment>
  </data>
  <data name="rxMarkdownUListItem" xml:space="preserve">
    <value>(?m:^(?&lt;listItem&gt;(?&lt;leadingSpace&gt;[\t ]*)-[\t ]{1,4}(?&lt;text&gt;.*))$)</value>
    <comment>Regular expression pattern to extract an unordered list item from Markdown text.</comment>
  </data>
  <data name="rxParameterExpression" xml:space="preserve">
    <value>(?s:%(?&lt;variable&gt;\w+[^%]*)%)</value>
    <comment>Regular expression pattern to extract percent-formatted parameter expressions from text.</comment>
  </data>
  <data name="rxSection" xml:space="preserve">
    <value>(?s:(?&lt;section&gt;\&lt;section\s*[^\&gt;]*(number\s*=\s*\"(?&lt;sectionNumber&gt;[^\"]*)\"){0,1}\s*\&gt;\s*(?&lt;content&gt;.*?)\s*\&lt;/section\&gt;))</value>
    <comment>Regular expression pattern to extract HTML sections from text.</comment>
  </data>
  <data name="rxSectionEnd" xml:space="preserve">
    <value>(?m:^[\t ]*(?&lt;element&gt;\&lt;/section\&gt;)\s*$)</value>
    <comment>Regular expression pattern to extract HTML section end elements from the text.</comment>
  </data>
  <data name="rxSectionStart" xml:space="preserve">
    <value>(?m:^[\t ]*(?&lt;element&gt;\&lt;section)\s*)</value>
    <comment>Regular expression pattern to extract HTML section start elements from the text.</comment>
  </data>
  <data name="rxStyleHxFontColor" xml:space="preserve">
    <value>(?i:(?&lt;name&gt;H(?&lt;digit&gt;\d)FontColor))</value>
    <comment>Regular expression pattern to match the value of H[0-9]FontColor.</comment>
  </data>
  <data name="rxStyleHxFontName" xml:space="preserve">
    <value>(?i:(?&lt;name&gt;H(?&lt;digit&gt;\d)FontName))</value>
    <comment>Regular expression pattern to match the value of H[0-9]FontName.</comment>
  </data>
  <data name="rxStyleHxFontSize" xml:space="preserve">
    <value>(?i:(?&lt;name&gt;H(?&lt;digit&gt;\d)FontSize))</value>
    <comment>Regular expression pattern to match the value of H[0-9]FontSize.</comment>
  </data>
  <data name="rxStyleHxType" xml:space="preserve">
    <value>(?m:(?i:^(?&lt;headtype&gt;H(\d|eading))))</value>
    <comment>Regular expression pattern to match the heading type of any of the heading style names.</comment>
  </data>
  <data name="rxStyleTableHeaderType" xml:space="preserve">
    <value>(?m:(?i:^(?&lt;styletype&gt;TableHeader)))</value>
    <comment>Regular expression pattern to match any of the table header style names.</comment>
  </data>
</root>